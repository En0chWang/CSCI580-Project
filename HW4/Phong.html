<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSCI 580 Homework 4 - Phong</title>
    <script type="text/javascript" src="teapot.js"></script>
    <script type="text/javascript" src="scene.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.2.0/lib/p5.js"></script>
    <script type="text/javascript">
      function setup() {
        createCanvas(512, 512)
        background(0)
        noStroke()
      }

      var Z = [[]]
      for (var r = 0; r < 512; ++r) {
        Z[r] = []
        for (var c = 0; c < 512; ++c) {
          Z[r][c] = Number.MAX_SAFE_INTEGER
        }
      }

      function toWorld(vector, r_vector, s_vector, t_vector, camMatrix) {
        var p1 = [vector.v[0], vector.v[1], vector.v[2], 1]
        var n1 = [vector.n[0], vector.n[1], vector.n[2], 1]
        n1 = unit(n1)

        // rotation
        var r = r_vector // deg
        r *= 3.1415 / 180
        var cos = Math.cos,
          sin = Math.sin
        var rMat = [
          cos(r),
          0,
          sin(r),
          0,
          0,
          1,
          0,
          0,
          -sin(r),
          0,
          cos(r),
          0,
          0,
          0,
          0,
          1,
        ]
        var ritMat = [
          cos(r),
          0,
          sin(r),
          0,
          0,
          1,
          0,
          0,
          -sin(r),
          0,
          cos(r),
          0,
          0,
          0,
          0,
          1,
        ] // itself

        var p2 = Mxp(rMat, p1)
        var n2 = Mxp(ritMat, n1)

        // scale
        var sx = s_vector[0]
        var sy = s_vector[1]
        var sz = s_vector[2]
        var sMat = [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]
        var sitMat = Mxpo([
          1 / sx,
          0,
          0,
          0,
          0,
          1 / sy,
          0,
          0,
          0,
          0,
          1 / sz,
          0,
          0,
          0,
          0,
          1,
        ]) // transpose is itself

        var p3 = Mxp(sMat, p2)
        var n3 = Mxp(sitMat, n2)
        n3 = unit(n3)

        // translation
        var tx = t_vector[0],
          ty = t_vector[1],
          tz = t_vector[2]
        var tMat = [1, 0, 0, tx, 0, 1, 0, ty, 0, 0, 1, tz, 0, 0, 0, 1]
        // var titMat = [0, 0, 0, 0, 0, 0, -tx, -ty, 1] // meaningless!

        var p4 = Mxp(tMat, p3)
        var n4 = n3

        var p5 = Mxp(
          [...camMatrix[0], ...camMatrix[1], ...camMatrix[2], ...camMatrix[3]],
          p4
        )

        var np4 = [p4[0] + n4[0], p4[1] + n4[1], p4[2] + n4[2], 1]
        var np5 = Mxp(
          [...camMatrix[0], ...camMatrix[1], ...camMatrix[2], ...camMatrix[3]],
          np4
        )

        var n5 = [np5[0] - p5[0], np5[1] - p5[1], np5[2] - p5[2], 1]

        return { v: p5, n: n5 }
      }

      function Mxp(M, p) {
        var x = M[0] * p[0] + M[1] * p[1] + M[2] * p[2] + M[3] * p[3]
        var y = M[4] * p[0] + M[5] * p[1] + M[6] * p[2] + M[7] * p[3]
        var z = M[8] * p[0] + M[9] * p[1] + M[10] * p[2] + M[11] * p[3]
        var a = M[12] * p[0] + M[13] * p[1] + M[14] * p[2] + M[15] * p[3]

        return [x, y, z, a]
      } // Mxp()

      function unit(v) {
        return [
          v[0] / Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]),
          v[1] / Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]),
          v[2] / Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]),
          1,
        ]
      }

      function Mxpo(M) {
        return [
          M[0],
          M[4],
          M[8],
          M[12],
          M[1],
          M[5],
          M[9],
          M[13],
          M[2],
          M[6],
          M[10],
          M[14],
          M[3],
          M[7],
          M[11],
          M[15],
        ]
      } // Mxpo()

      function draw() {
        var arr = teapot.data
        // len of 4
        var shapes = scene.scene.shapes
        var { lights } = scene.scene
        // create a 4 x 4 cam matrix
        const camMatrix = createCamMatrix([3, 4, 10], [0, 0, 0])
        const NDCMatrix = createNDCMatrix()

        for (shape of shapes) {
          var rotation = shape.transforms[0].Ry
          var scale = shape.transforms[1].S
          var translation = shape.transforms[2].T
          var { material } = shape
          for (each of arr) {
            const { v0, v1, v2 } = each

            var v0_obj = toWorld(v0, rotation, scale, translation, camMatrix)
            var v1_obj = toWorld(v1, rotation, scale, translation, camMatrix)
            var v2_obj = toWorld(v2, rotation, scale, translation, camMatrix)

            var res0 = v0_obj.v
            var res1 = v1_obj.v
            var res2 = v2_obj.v

            res0 = Mxp(
              [
                ...NDCMatrix[0],
                ...NDCMatrix[1],
                ...NDCMatrix[2],
                ...NDCMatrix[3],
              ],
              res0
            )
            ;(x0 = res0[0]), (y0 = res0[1]), (z0 = res0[2]), (w0 = res0[3])
            ;(x0 = x0 / w0), (y0 = y0 / w0), (z0 = z0 / w0)

            x0 = (x0 + 1) * (511 / 2)
            y0 = -(y0 + 1) * (511 / 2) + 511

            res1 = Mxp(
              [
                ...NDCMatrix[0],
                ...NDCMatrix[1],
                ...NDCMatrix[2],
                ...NDCMatrix[3],
              ],
              res1
            )
            x1 = res1[0]
            y1 = res1[1]
            z1 = res1[2]
            w1 = res1[3]
            x1 = x1 / w1
            y1 = y1 / w1
            z1 = z1 / w1

            x1 = (x1 + 1) * (511 / 2)
            y1 = -(y1 + 1) * (511 / 2) + 511

            res2 = Mxp(
              [
                ...NDCMatrix[0],
                ...NDCMatrix[1],
                ...NDCMatrix[2],
                ...NDCMatrix[3],
              ],
              res2
            )
            ;(x2 = res2[0]), (y2 = res2[1]), (z2 = res2[2]), (w2 = res2[3])
            ;(x2 = x2 / w2), (y2 = y2 / w2), (z2 = z2 / w2)

            x2 = (x2 + 1) * (511 / 2)
            y2 = -(y2 + 1) * (511 / 2) + 511

            scanConvert(
              x0,
              y0,
              z0,
              x1,
              y1,
              z1,
              x2,
              y2,
              z2,
              v0_obj.n,
              v1_obj.n,
              v2_obj.n,
              camMatrix,
              material,
              lights
            )
          }
        }
      }

      function createCamMatrix(camR, to) {
        let camN = []
        for (var i = 0; i < 3; i++) {
          camN[i] = camR[i] - to[i] // from-to, from needs to be the tip
        }
        camN = unitize(camN)
        camV = []
        camV[0] = 0
        camV[1] = 1
        camV[2] = 0 // fake V, just to create U

        camU = cross(camV, camN)

        camU = unitize(camU)
        camV = cross(camN, camU)

        camMat = [
          [
            camU[0],
            camU[1],
            camU[2],
            -camR[0] * camU[0] - camR[1] * camU[1] - camR[2] * camU[2],
          ],
          [
            camV[0],
            camV[1],
            camV[2],
            -camR[0] * camV[0] - camR[1] * camV[1] - camR[2] * camV[2],
          ],
          [
            camN[0],
            camN[1],
            camN[2],
            -camR[0] * camN[0] - camR[1] * camN[1] - camR[2] * camN[2],
          ],
          [0, 0, 0, 1],
        ]
        return camMat
      }

      function createNDCMatrix() {
        var near = 3,
          far = 10,
          right = 1,
          left = -1,
          top = 1,
          bottom = -1
        ndc = [
          [(2 * near) / (right - left), 0, (right + left) / (right - left), 0],
          [0, (2 * near) / (top - bottom), (top + bottom) / (top - bottom), 0],
          [
            0,
            0,
            (-1 * (far + near)) / (far - near),
            (-2 * far * near) / (far - near),
          ],
          [0, 0, -1, 0],
        ]

        return ndc
      }

      // unitize an array of 3 elements
      function unitize(arr) {
        let total = Math.sqrt(
          arr[0] * arr[0] + arr[1] * arr[1] + arr[2] * arr[2]
        )
        return [arr[0] / total, arr[1] / total, arr[2] / total]
      }

      function cross(a, b) {
        return [
          a[1] * b[2] - a[2] * b[1],
          a[2] * b[0] - a[0] * b[2],
          a[0] * b[1] - a[1] * b[0],
        ]
      }

      function f01(x0, y0, x1, y1, x2, y2) {
        return (x, y) => {
          return (y0 - y1) * x + (x1 - x0) * y + x0 * y1 - x1 * y0
        }
      }

      function f12(x0, y0, x1, y1, x2, y2) {
        return (x, y) => {
          return (y1 - y2) * x + (x2 - x1) * y + x1 * y2 - x2 * y1
        }
      }
      function f20(x0, y0, x1, y1, x2, y2) {
        return (x, y) => {
          return (y2 - y0) * x + (x0 - x2) * y + x2 * y0 - x0 * y2
        }
      }

      function scanConvert(
        x0,
        y0,
        z0,
        x1,
        y1,
        z1,
        x2,
        y2,
        z2,
        n0,
        n1,
        n2,
        camMatrix,
        material,
        lights
      ) {
        if (x0 < 0) {
          x0 = 0
        }
        if (x1 < 0) {
          x1 = 0
        }
        if (x2 < 0) {
          x2 = 0
        }
        if (x0 > 511) {
          x0 = 511
        }
        if (x1 > 511) {
          x1 = 511
        }
        if (x2 > 511) {
          x2 = 511
        }

        if (y0 < 0) {
          y0 = 0
        }
        if (y1 < 0) {
          y1 = 0
        }
        if (y2 < 0) {
          y2 = 0
        }
        if (y0 > 511) {
          y0 = 511
        }
        if (y1 > 511) {
          y1 = 511
        }
        if (y2 > 511) {
          y2 = 511
        }

        xmin = Math.floor(Math.min(x0, x1, x2))
        xmax = Math.ceil(Math.max(x0, x1, x2))
        ymin = Math.floor(Math.min(y0, y1, y2))
        ymax = Math.ceil(Math.max(y0, y1, y2))

        for (var y = ymin; y <= ymax; y++) {
          for (var x = xmin; x <= xmax; x++) {
            alph =
              f12(x0, y0, x1, y1, x2, y2)(x, y) /
              f12(x0, y0, x1, y1, x2, y2)(x0, y0)
            beta =
              f20(x0, y0, x1, y1, x2, y2)(x, y) /
              f20(x0, y0, x1, y1, x2, y2)(x1, y1)
            gamma =
              f01(x0, y0, x1, y1, x2, y2)(x, y) /
              f01(x0, y0, x1, y1, x2, y2)(x2, y2)

            z_at_pixel = alph * z0 + beta * z1 + gamma * z2

            if (alph >= 0 && beta >= 0 && gamma >= 0) {
              normal = [0, 0, 0]
              normal[0] = alph * n0[0] + beta * n1[0] + gamma * n2[0]
              normal[1] = alph * n0[1] + beta * n1[1] + gamma * n2[1]
              normal[2] = alph * n0[2] + beta * n1[2] + gamma * n2[2]
              if (z_at_pixel < Z[x][y]) {
                firstColor = computeTriangleColor(
                  [x0, y0, z0],
                  normal,
                  camMatrix,
                  material,
                  lights
                )
                secondColor = computeTriangleColor(
                  [x1, y1, z1],
                  normal,
                  camMatrix,
                  material,
                  lights
                )
                thirdColor = computeTriangleColor(
                  [x2, y2, z2],
                  normal,
                  camMatrix,
                  material,
                  lights
                )

                R_pixel =
                  alph * firstColor[0] +
                  beta * secondColor[0] +
                  gamma * thirdColor[0]
                G_pixel =
                  alph * firstColor[1] +
                  beta * secondColor[1] +
                  gamma * thirdColor[1]
                B_pixel =
                  alph * firstColor[2] +
                  beta * secondColor[2] +
                  gamma * thirdColor[2]

                Z[x][y] = z_at_pixel
                set(x, y, color(R_pixel, G_pixel, B_pixel))
              }
            }
          }
        }
        updatePixels()
      }

      function computeTriangleColor(p, n, camMatrix, material, lights) {
        const { Cs, Ka, Kd, Ks } = material
        const s = material.n

        // color * indensity
        const a_intensity = lights[0].intensity
        const a_color_arr = lights[0].color
        var a_color = [
          a_color_arr[0] * a_intensity,
          a_color_arr[1] * a_intensity,
          a_color_arr[2] * a_intensity,
        ]

        const s_intensity = lights[1].intensity
        const s_color_arr = lights[1].color
        var s_color = [
          s_color_arr[0] * s_intensity,
          s_color_arr[1] * s_intensity,
          s_color_arr[2] * s_intensity,
        ]

        // light direction
        const { from, to } = lights[1]

        // light direction
        var L = Mxp(
          [...camMatrix[0], ...camMatrix[1], ...camMatrix[2], ...camMatrix[3]],
          [from[0] - to[0], from[1] - to[1], from[2] - to[2], 1]
        )
        L = unitize([L[0], L[1], L[2]])

        // Eye vector
        var E = unitize([0, 0, -1])

        // vert normal
        var N = unitize(n)

        // NxL < 0 and NxE < 0 => flip normal vector
        if (
          N[0] * L[0] + N[1] * L[1] + N[2] * L[2] < 0 &&
          N[0] * E[0] + N[1] * E[1] + N[2] * E[2] < 0
        ) {
          N = [-1 * N[0], -1 * N[1], -1 * N[2]]
        }

        var NdotL = N[0] * L[0] + N[1] * L[1] + N[2] * L[2]
        var NdotE = N[0] * E[0] + N[1] * E[1] + N[2] * E[2]

        var R = unitize([
          2 * NdotL * N[0] - L[0],
          2 * NdotL * N[1] - L[1],
          2 * NdotL * N[2] - L[2],
        ])

        var am = ambient(Ka, a_color)
        var diff = diffuse(Kd, N, L, s_color)
        var spec = specular(Ks, R, E, s, s_color)

        // NdotL and NdotE have different signs => lighting model = 0
        if (NdotL * NdotE < 0) {
          diff = [0, 0, 0]
          spec = [0, 0, 0]
        }

        total = [
          Cs[0] * (am[0] + diff[0] + spec[0]),
          Cs[1] * (am[1] + diff[1] + spec[1]),
          Cs[2] * (am[2] + diff[2] + spec[2]),
        ]
        return [total[0] * 255, total[1] * 255, total[2] * 255]
      }

      function ambient(Ka, color) {
        return [Ka * color[0], Ka * color[1], Ka * color[2]]
      }
      function diffuse(Kd, N, L, color) {
        var tt = Math.max(0, N[0] * L[0] + N[1] * L[1] + N[2] * L[2])
        return [Kd * tt * color[0], Kd * tt * color[1], Kd * tt * color[2]]
      }
      function specular(Ks, R, E, s, color) {
        var tt = Math.max(0, R[0] * E[0] + R[1] * E[1] + R[2] * E[2])
        var temp = Math.pow(tt, s)
        return [
          Ks * temp * color[0],
          Ks * temp * color[1],
          Ks * temp * color[2],
        ]
      }
    </script>
  </head>

  <body></body>
</html>
